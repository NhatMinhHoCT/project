<!DOCTYPE html>
<html>

<head>
  <title>Seat Booking</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body>
  <div class="container">
    <h1>Seat Booking</h1>
    <div class="row">
      <div class="col-md-6">
        <table>
          <tbody>
            <!-- Generate table rows using a for loop -->
            <script>
              const numRows = 6;
              const numCols = 3;
              const bookedSeats = ["A1", "A3", "A4"];

              for (let row = 0; row < numRows; row++) {
                const tr = document.createElement('tr');

                for (let col = 0; col < numCols; col++) {
                  const td = document.createElement('td');
                  const seatId = `A${row * numCols + col + 1}`;

                  if (row === 0 && col === 1) {
                    // Empty cell in the first row, middle column
                    td.innerHTML = '';
                  } else {
                    const span = document.createElement('span');
                    span.id = seatId;
                    span.classList.add('btn', 'btn-outline-primary');
                    span.textContent = seatId;
                    td.appendChild(span);
                  }

                  tr.appendChild(td);
                }

                document.querySelector('tbody').appendChild(tr);
              }

              // Get all seat elements
              const seatElements = document.querySelectorAll('span.btn');

              // Loop through each seat element
              seatElements.forEach(seat => {
                const seatId = seat.id;

                // Check if the seat is booked
                if (bookedSeats.includes(seatId)) {
                  // Change the class and disable the seat
                  seat.classList.remove('btn-outline-primary');
                  seat.classList.add('btn-dark');
                  seat.disabled = true;
                } else {
                  // Add click event listener for available seats
                  seat.addEventListener('click', () => {
                    alert(`You selected seat ${seatId}`);
                  });
                }
              });
            </script>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</body>

</html>

To link the main.js file located in the resources/js folder from your Blade file inside the views folder, you can use the asset helper function provided by Laravel. Here's how you can do it:

First, make sure that the main.js file is included in the resources/js/app.js file. This is necessary because Laravel's asset pipeline compiles and bundles all JavaScript files referenced in app.js.
In resources/js/app.js, add the following line:

import './main.js';



In your Blade file (e.g., resources/views/your-view.blade.php), you can link the compiled JavaScript file using the asset helper function:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your View</title>
</head>
<body>
    <!-- Your HTML content -->

    <!-- Link the compiled JavaScript file -->
    <script src="{{ asset('js/app.js') }}"></script>
</body>
</html>



The asset helper function generates the correct URL for the compiled JavaScript file based on your application's public path.

Make sure to run the following command to compile your JavaScript assets:
npm run dev



This command will compile your JavaScript files, including main.js, and create the public/js/app.js file, which you can then link in your Blade file.

After following these steps, your main.js file will be included in the compiled app.js file, and you can access its functionality in your Blade view.

Note that if you make changes to your JavaScript files, you'll need to re-run the npm run dev command to recompile the assets and see the changes reflected in your application.



Try again with different context
Add context...
Avatar for honhatminh1510-cfizq



To count the active schedules for a specific date in Laravel Eloquent, you can use a query with a whereNotExists subquery to exclude the schedules that have a cancellation record for the given date.

Here's an example of how you can do it:

use Illuminate\Support\Carbon;

$date = Carbon::parse('2024-06-24'); // Replace with the desired date

$activeSchedulesCount = \App\Models\Schedule::whereNotExists(function ($query) use ($date) {
    $query->select('schedule_id')
          ->from('schedule_cancels')
          ->whereRaw('? BETWEEN start_cancel AND end_cancel', [$date->toDateString()])
          ->whereColumn('schedule_cancels.schedule_id', 'schedules.id');
})->count();



Let's break down the code:

First, we create a Carbon instance with the desired date using Carbon::parse('2024-06-24').

Then, we use the whereNotExists method on the Schedule model to exclude schedules that have a cancellation record for the given date.

Inside the whereNotExists closure, we define a subquery that selects the schedule_id from the schedule_cancels table where the given date falls between the start_cancel and end_cancel dates.

We use the whereRaw method to construct a raw SQL condition that checks if the given date is between start_cancel and end_cancel. The ? placeholder is used to bind the date value.

We also add a whereColumn condition to match the schedule_id from the schedule_cancels table with the id column in the schedules table.

Finally, we call the count() method on the main query to get the count of active schedules.

The resulting $activeSchedulesCount variable will contain the count of active schedules for the specified date.

Note: Make sure to replace \App\Models\Schedule with the actual namespace and class name of your Schedule model. Also, adjust the table and column names according to your database schema.
$query = Ticket::join('schedules', 'tickets.schedule_id', '=', 'schedules.id')
                ->join('roads', 'schedules.road_id', '=', 'roads.id');

// Filter by start_point
if ($request->has('start_point')) {
    $query->where('roads.start_point', $request->input('start_point'));
}

// Filter by end_point
if ($request->has('end_point')) {
    $query->where('roads.end_point', $request->input('end_point'));
}

// Filter by date_of_depart
if ($request->has('date')) {
    $query->whereDate('tickets.date_of_depart', $request->input('date'));
}

// Filter by ticketcount (assuming you want to check for available seats)
if ($request->has('ticketcount')) {
    $query->havingRaw('COUNT(tickets.id) < ?', [$request->input('ticketcount')]);
}

$results = $query->select('roads.start_point', 'roads.end_point', 'roads.duration', 'schedules.departure_time', 'tickets.date_of_depart')
                  ->groupBy('schedules.id', 'tickets.date_of_depart')
                  ->get();





To achieve this, you can use a combination of JOIN and subqueries to retrieve the desired information. Here's an example query that should work:

SELECT
    s.id AS schedule_id,
    s.departure_time,
    r.start_point,
    r.end_point,
    COALESCE(t.ticket_count, 0) AS ticket_count
FROM
    schedules s
JOIN
    roads r ON s.road_id = r.id
LEFT JOIN
    (
        SELECT
            schedule_id,
            COUNT(*) AS ticket_count
        FROM
            tickets
        WHERE
            date_of_depart = '2024-07-01'
        GROUP BY
            schedule_id
    ) t ON s.id = t.schedule_id
WHERE
    r.start_point = ? AND r.end_point = ?
ORDER BY
    s.departure_time;



Here's a breakdown of the query:

The main query selects the schedule_id, departure_time, start_point, end_point, and ticket_count columns.
The schedules table is joined with the roads table using the road_id foreign key.
A subquery is used to count the number of tickets for each schedule_id on the specified date (2024-07-01). This subquery is LEFT JOINed with the main query to include schedules that have no tickets.
The COALESCE function is used to replace NULL values (for schedules with no tickets) with 0.
The WHERE clause filters the results based on the start_point and end_point parameters.
The results are ordered by departure_time.
You can replace the ? placeholders with the actual values for start_point and end_point obtained from the GET form.

This query will return all the schedules for the specified date, along with the start and end points, departure time, and the number of tickets booked for each schedule. If there are no tickets booked for a particular schedule, the ticket_count will be 0.



Try again with different context
Public knowledge only
Add context...
Avatar for honhatminh1510-cfizq
 i have 3 tables, table roads contains id, start_point, end_point;table schedules contains id, road_id, departure_time(eg: 04:00 AM); table tickets has id, schedule_id, date_of_depart(eg 2024/06/20). The schedules will run and repeat each day, but the tickets on each day may vary. I want to query the schedules on 1 day (example like 2024/07/01), with parameters from get form are start_point, end_point, date, ticket_booking_quantity. The query should return all the schedules on that day and count the number of ticket for each schedule, if there is no ticket on this schedule, it will count as 0.
I forgot to say that i used eloquent ORM to query

If you're using Eloquent ORM in Laravel, you can achieve the desired result by using relationships and subqueries. Here's an example of how you can query the schedules with the required conditions:

use Illuminate\Support\Facades\DB;

$startPoint = request()->input('start_point');
$endPoint = request()->input('end_point');
$date = request()->input('date');
$ticketBookingQuantity = request()->input('ticket_booking_quantity');

$schedules = Schedule::whereHas('road', function ($query) use ($startPoint, $endPoint) {
    $query->where('start_point', $startPoint)
          ->where('end_point', $endPoint);
})
->with(['road', 'tickets' => function ($query) use ($date) {
    $query->whereDate('date_of_depart', $date);
}])
->get()
->map(function ($schedule) use ($ticketBookingQuantity) {
    $ticketCount = $schedule->tickets->count();
    $schedule->ticket_count = $ticketCount >= $ticketBookingQuantity ? $ticketCount : 0;
    return $schedule;
});



Here's a breakdown of the code:

First, we retrieve the start_point, end_point, date, and ticket_booking_quantity values from the request.
We use the whereHas method to filter the Schedule model based on the start_point and end_point conditions. This method uses the road relationship to access the roads table.
We use the with method to eager load the road and tickets relationships. For the tickets relationship, we filter the tickets based on the date_of_depart condition.
We use the get method to retrieve the filtered schedules.
We use the map method to iterate over the retrieved schedules and calculate the ticket_count for each schedule.
If the number of tickets for a schedule is greater than or equal to the ticket_booking_quantity, we set the ticket_count to the actual count of tickets.
If the number of tickets for a schedule is less than the ticket_booking_quantity, we set the ticket_count to 0.
The modified schedules with the ticket_count property are returned.
Assuming you have the following relationships defined in your models:

// Road model
class Road extends Model
{
    public function schedules()
    {
        return $this->hasMany(Schedule::class);
    }
}

// Schedule model
class Schedule extends Model
{
    public function road()
    {
        return $this->belongsTo(Road::class);
    }

    public function tickets()
    {
        return $this->hasMany(Ticket::class);
    }
}

// Ticket model
class Ticket extends Model
{
    public function schedule()
    {
        return $this->belongsTo(Schedule::class);
    }
}



This code should give you the desired result, where you'll get all the schedules for the specified date, along with the start and end points, and the ticket_count for each schedule, considering the ticket_booking_quantity condition.


use Illuminate\Support\Facades\DB;

$startPoint = request()->input('start_point');
$endPoint = request()->input('end_point');
$date = request()->input('date');
$ticketBookingQuantity = request()->input('ticket_booking_quantity');

$schedules = Schedule::whereHas('road', function ($query) use ($startPoint, $endPoint) {
    $query->where('start_point', $startPoint)
          ->where('end_point', $endPoint);
})
->with(['road', 'tickets' => function ($query) use ($date) {
    $query->whereDate('date_of_depart', $date);
}])
->addSelect([
    'available_seats' => DB::raw('34 - COALESCE((
        SELECT SUM(t.ticket_booking_quantity)
        FROM tickets t
        WHERE t.schedule_id = schedules.id
        AND t.date_of_depart = ?
    ), 0)')
])
->having('available_seats', '>=', $ticketBookingQuantity)
->get();

Certainly! I'll provide you with a code sample that demonstrates how to implement AJAX-based search and pagination for a Laravel table display. This example will include both the Laravel backend and the JavaScript/jQuery frontend code.

First, let's start with the Laravel controller:

// app/Http/Controllers/DataController.php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\YourModel;

class DataController extends Controller
{
    public function index(Request $request)
    {
        $query = YourModel::query();

        if ($request->has('search')) {
            $searchTerm = $request->input('search');
            $query->where('column_name', 'LIKE', "%{$searchTerm}%");
        }

        $perPage = 10; // Number of items per page
        $page = $request->input('page', 1);
        $data = $query->paginate($perPage, ['*'], 'page', $page);

        if ($request->ajax()) {
            return response()->json([
                'data' => view('partials.table_rows', compact('data'))->render(),
                'pagination' => view('partials.pagination', compact('data'))->render(),
            ]);
        }

        return view('data_table', compact('data'));
    }
}



Now, let's create the main view and the partial views:

<!-- resources/views/data_table.blade.php -->

@extends('layouts.app')

@section('content')
    <div class="container">
        <h1>Data Table</h1>
        <input type="text" id="search" placeholder="Search...">
        <table id="data-table">
            <thead>
                <tr>
                    <th>Column 1</th>
                    <th>Column 2</th>
                    <!-- Add more columns as needed -->
                </tr>
            </thead>
            <tbody id="table-body">
                @include('partials.table_rows', ['data' => $data])
            </tbody>
        </table>
        <div id="pagination">
            @include('partials.pagination', ['data' => $data])
        </div>
    </div>
@endsection

@push('scripts')
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
    $(document).ready(function() {
        function loadData(url) {
            $.ajax({
                url: url,
                type: 'GET',
                data: {
                    search: $('#search').val()
                },
                success: function(response) {
                    $('#table-body').html(response.data);
                    $('#pagination').html(response.pagination);
                    history.pushState(null, '', url);
                }
            });
        }

        $('#search').on('keyup', function() {
            loadData('{{ route("data.index") }}');
        });

        $(document).on('click', '.pagination-btn', function(e) {
            e.preventDefault();
            loadData($(this).val());
        });
    });
</script>
@endpush



Create the partial views for table rows and pagination:

<!-- resources/views/partials/table_rows.blade.php -->

@foreach ($data as $item)
    <tr>
        <td>{{ $item->column1 }}</td>
        <td>{{ $item->column2 }}</td>
        <!-- Add more columns as needed -->
    </tr>
@endforeach



<!-- resources/views/partials/pagination.blade.php -->

@if ($data->hasPages())
    <div class="pagination">
        @if ($data->onFirstPage())
            <button class="pagination-btn" disabled>Previous</button>
        @else
            <button class="pagination-btn" value="{{ $data->previousPageUrl() }}">Previous</button>
        @endif

        @foreach ($data->getUrlRange(1, $data->lastPage()) as $page => $url)
            <button class="pagination-btn" value="{{ $url }}" {{ $page == $data->currentPage() ? 'disabled' : '' }}>
                {{ $page }}
            </button>
        @endforeach

        @if ($data->hasMorePages())
            <button class="pagination-btn" value="{{ $data->nextPageUrl() }}">Next</button>
        @else
            <button class="pagination-btn" disabled>Next</button>
        @endif
    </div>
@endif



Finally, add the route in your routes/web.php file:

Route::get('/data', [DataController::class, 'index'])->name('data.index');



This code sample provides:

A Laravel controller that handles both the initial page load and AJAX requests.
A main view that displays the table and includes the search input and pagination.
Partial views for table rows and pagination buttons.
JavaScript code that handles the AJAX requests for search and pagination.
URL updates using history.pushState() to reflect the current page without reloading.
When you search or click on a pagination button, it will load the data without reloading the page and update the URL accordingly. The pagination buttons use the current URL with query parameters as their values, as requested.

Remember to adjust the model name, column names, and styling to fit your specific needs.



Try again with different context
Add context...
Avatar for honhatminh1510-cfizq
